# scroll-io

Wrapper for IntersectionObserver that returns the scroll direction and state

```
npm i @imjasonmiller/scroll-io
```

### Example 

```js
import ScrollIO from '@imjasonmiller/scroll-io';

// Cache all '.captions', each a child of '.feature'
const captions = document.querySelectorAll('.caption');

const handleIntersect = ({ index, state, scroll }, entry) => {
    const ratio = entry.intersectionRatio;

    if (state === 'enter' && scroll === 'down' ||
        state === 'leave' && scroll === 'up') {
        captions[index].style.transform = `translateY(${50 * (1 - ratio)}%)`;
        captions[index].style.opacity = ratio;
    }
};

const observer = new ScrollIO({
    elements: '.feature',
    threshold: { steps: 50 },
    onIntersect: handleIntersect,
});
```

## Options

### `elements`

| Default | Type   |
| ------- | ------ |
| `null`  | String \| Element \| NodeList \| Array |

### `threshold`

| Default                         | Type   |
| ------------------------------- | ------ |
| `{ min: 0, max: 1, steps: 0 }`  | Object |

A wide range of thresholds can easily be generated by passing a number to `steps`. Passing `4` will generate: `[0, 0.25, 0.5, 0.75, 1.0]`, as each step will be `(max - min) / steps = 0.25`.

If you would like to limit the range, set `min` or/and `max`.

If you want to pass a single threshold value, you only have to pass `min`.

### `onIntersect`

| Default | Type     |
| ------- | -------- |
| `null`  | Function |

Handler that is called on each intersect and receives the following arguments:

```ts
{
  index: number,
  scroll: 'up' | 'down',
  state: 'enter' | 'leave',
},
entry: IntersectionObserverEntry,
observer: IntersectionObserver,
```

If needed, the `index` for each added element allows you to build a cache outside of the handler, preventing costly `querySelector` calls when accessing the element's children.

### `namespace`

| Default      | Type   |
| ------------ | ------ |
| `__scrollio` | String |

Each `HTMLElement` passed to `elements` will have a property attached to it in order to keep track of the `index`, `scroll` direction (up/down), `state` (enter/leave). The default namespace can be changed if there is a conflict.

## Methods

### `disconnect()`

Disconnects the IntersectionObserver and clears the elements that were passed to it.

